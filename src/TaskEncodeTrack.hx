package;

import app.EcmTools;
import app.FFmpegAudio;
import cd.CDTrack;
import djNode.task.CTask;
import djNode.tools.FileTool;
import djNode.utils.CLIApp;
import js.Node;
import js.node.Fs;
import js.node.Path;


/**
 * - Compresses a Track (data or audio)
 * 
 * CHANGES:
 *  - track.workingFile -> points to the new encoded file path
 *  - track.storedFileName -> is set to just a filename. e.g (track02.ogg) How it's saved in the archive?
 *  - file `track.workingFile` is deleted
 * ...
 */

class TaskEncodeTrack extends CTask 
{
	// Pointer to currently running parameters
	var p:CDCRUSH.CrushParams;
	
	// Pointer to working track
	var track:CDTrack;
	
	// Temp Name, Autogenerated
	var sourceTrackFile:String;

	public function new(tr:CDTrack) 
	{
		super(null, "Encoding Track " + tr.trackNo);
		track = tr;
	}
	
	// Qucikly set based on extension
	// @param ext, comes with "."
	// + track.storedFileName
	// + track.workingFile
	function setupFiles(ext:String)
	{
		track.storedFileName = track.getTrackName() + ext;

		if (p.flag_convert_only) {
			// Convert files to output folder directly
			track.workingFile = Path.join(p.outputDir, track.storedFileName);
		}else{
			// Convert files to temp folder, since they are going to be archived later
			track.workingFile = Path.join(p.tempDir, track.storedFileName);
		}
	}// -----------------------------------------
	
	// --
	override public function start() 
	{
		super.start();
		
		p = cast jobData;
		
		sourceTrackFile = track.workingFile;
		
		// Get track MD5
		track.md5 = FileTool.getFileMD5(sourceTrackFile);
		if (track.md5 == null)
		{
			fail("Could not calculate MD5 of " + sourceTrackFile);
		}
		
		
		if (track.isData)
		{
			var ecm = new EcmTools(CDCRUSH.TOOLS_PATH);
			ecm.events.on("progress", onProgress);
			ecm.events.once("close", onClose);
			setupFiles(".bin.ecm"); // sets up working file
			ecm.ecm(sourceTrackFile, track.workingFile);
			killExtra = function() { ecm.kill(); }	
			
		}else{
			
			var ffmp = new FFmpegAudio(CDCRUSH.FFMPEG_PATH);
			ffmp.events.on("progress", onProgress);
			ffmp.events.once("close", onClose);	
			killExtra = function() { ffmp.kill(); }	

			// Audio Quality ::
			switch(p.audio.id)
			{
				case "flac":
					setupFiles('.flac');
					ffmp.audioPCMToFlac(sourceTrackFile, track.workingFile);
				case "vorbis":
					setupFiles('.ogg');
					ffmp.audioPCMToOggVorbis(sourceTrackFile, p.audio.quality, track.workingFile);
				case "opus":
					setupFiles('.ogg');
					ffmp.audioPCMToOggOpus(sourceTrackFile, 
						FFmpegAudio.OPUS_QUALITY[p.audio.quality], track.workingFile);
				case "mp3":
					setupFiles('.mp3');
					ffmp.audioPCMToMP3(sourceTrackFile, p.audio.quality, track.workingFile);
					
				default: fail("Unsupported Audio Codec " + p.audio.id);
			}//-
			
		}// -- end if
		
		
	}//---------------------------------------------------;
	
	
	// CLI App progress event
	function onProgress(p:Int)
	{
		PROGRESS = p;// uses setter
	}//---------------------------------------------------;
	
	// CLI App close event
	function onClose(s:Bool, m:String)
	{
		if (s){
			deleteOldFile();
			complete();
		}else{
			fail(m);
		}
	}//---------------------------------------------------;
	
	// Delete old files ONLY IF they reside in the TEMP folder!
	function deleteOldFile()
	{
		if (!CDCRUSH.FLAG_KEEP_TEMP && p.flag_tracksOnTempFolder) {
			Fs.unlinkSync(sourceTrackFile);
		}
	}//---------------------------------------------------;
	
}// --