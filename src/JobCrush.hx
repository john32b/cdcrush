package;

import app.Archiver;
import app.FreeArc;
import cd.CDInfos;
import djNode.task.CJob;
import djNode.task.CTask;
import djNode.tools.FileTool;
import djNode.tools.LOG;
import js.node.Fs;
import js.node.Path;
import CDCRUSH.CrushParams;


/*
 * CRUSH a CD
 */
@:allow(TaskEncodeTrack)
@:allow(TaskCutTrackFiles)
class JobCrush extends CJob 
{
	// Temp dir for the current batch, Is a subfolder of the master TEMP folder.
	var tempDir:String;
	// Keep the CD infos of the CD, it is going to be read later
	var cd:CDInfos;
	// Filesize of the final archive
	var crushedSize:Int;
	// Final destination ARCHIVE file, Name is autogenerated from CD TITLE
	var final_arc:String;
	// If true, then all the track files are stored in temp folder and safe to delete
	var flag_tracksOnTempFolder:Bool;
	// USED in `JobConvertCue`
	var flag_convert_only:Bool;
	// Used for reporting back to user
	var convertedCuePath:String;
	// The running parameters
	var p:CrushParams;
	
	var AC:SettingsTuple;
	var DC:SettingsTuple;
	
	// --
	public function new(P:CrushParams)
	{
		super("crush");
		p = P;
	}//---------------------------------------------------;
	
	// NOTE: Thrown Errors are OK and handled by <CJob>
	// --
	override public function init() 
	{
		// - Any parse errors in ac/dc settings should be checked on MAIN and error to user from there
		// - ac/dc strings should be normalized before here
		if (p.ac == null) p.ac = CodecMaster.DEFAULT_AUDIO_PARAM;
		if (p.dc == null) p.dc = CodecMaster.DEFAULT_ARCHIVER_PARAM;
		AC = CodecMaster.getSettingsTuple(p.ac);
		DC = CodecMaster.getSettingsTuple(p.dc);
		
		tempDir = CDCRUSH.getSubTempDir();
		
		CDCRUSH.checkFileQuick(p.inputFile, CDCRUSH.CUE_EXTENSION);
		
		if (p.outputDir == null || p.outputDir.length == 0) {
			p.outputDir = Path.dirname(p.inputFile);
		}
		
		FileTool.createRecursiveDir(p.outputDir);
		FileTool.createRecursiveDir(p.tempDir);
		
		// -- Make sure this is set
		p.flag_convert_only = false;
		
		LOG.log('== Creating a CRUSH Job with these parameters :');
		LOG.log(' - Input : ' + p.inputFile);
		LOG.log(' - Output Dir : ' + p.outputDir);
		LOG.log(' - Audio Compression : ' + p.ac);
		LOG.log(' - Archive Compression : ' + p.dc);
		
		// --- START ADDING JOBS : ----
		
		addQ("-Reading CUE Data & Preparing", (t)-> 
		{
			cd = new CDInfos();
			cd.cueLoad(p.inputFile);
			
			// Human Readable Audio Quality String
			cd.CD_AUDIO_QUALITY = CodecMaster.getAudioQualityInfo(AC);

			// Generate the final arc name now that I have the CD TITLE
			final_arc = Path.join(p.outputDir, cd.CD_TITLE + CodecMaster.getArcExt(DC.id));
			
			// Do not overwrite archive if exists, rather rename the new file until unique
			// This is rare, but worth checking
			while (FileTool.pathExists(final_arc))
			{
				LOG.log(final_arc + " already exists, adding (_) until unique", 2);
				final_arc = final_arc.substr(0, -4) + "_" + CodecMaster.getArcExt(DC.id);
			}
			
			LOG.log("- Destination Archive :" + final_arc );
			
			t.complete();
		});
		
		// - Cut tracks
		// ---------------------------
		add(new TaskCutTrackFiles());
		
		// - Encode tracks
		// ---------------------
		addQ("-Preparing to Compress",(t)->
		{
			for (tr in cd.tracks) addNextAsync(new TaskEncodeTrack(tr));
			t.complete();
		});

		// I need this to be on this scope
		var A:Archiver;
		
		// Create Archive
		// Add all tracks to the final archive
		// ---------------------
		addQ("Creating Archive",(t)->
		{
			// Dev note: working file was set earlier on TaskEncodeTrack();
			var files:Array<String> = [ for (tr in cd.tracks) tr.workingFile ];
			// -
			var path_settings = Path.join(tempDir, CDCRUSH.CDCRUSH_SETTINGS);
			cd.jsonSave(path_settings);
			files.push(path_settings);
			
			// TODO -> Proper Archiver
			A = CodecMaster.getArchiver(DC.id);
				t.syncWith(A);
				t.killExtra = A.kill;
				A.compress(files, final_arc, CodecMaster.getArchiverStr(DC));
		});
		
		// - Get post data
		addQ((t)->
		{
			crushedSize = A.COMPRESSED_SIZE;
			LOG.log( "== Detailed CD INFOS:\n" +  cd.getDetailedInfo() );
			t.complete();
		});
		
	}//---------------------------------------------------;
		
	
	// --
	override function kill() 
	{
		super.kill();
		if (CDCRUSH.FLAG_KEEP_TEMP) return;
		if (tempDir != p.outputDir) {
			LOG.log("Deleting tempdir : " + p.tempDir);
			FileTool.deleteRecursiveDir(p.tempDir);
		}
	}//---------------------------------------------------;
	
}// --




